{"file":"/home/omar/Desktop/Protofolio_without_redis/src/log/filters/all-exceptions.filter.ts","mappings":";;;;;;;;;;;;;AAAA,2CAMwB;AACxB,gDAA4C;AAGrC,IAAM,mBAAmB,GAAzB,MAAM,mBAAmB;IACD;IAA7B,YAA6B,QAAoB;QAApB,aAAQ,GAAR,QAAQ,CAAY;IAAG,CAAC;IAErD,KAAK,CAAC,KAAK,CAAC,SAAkB,EAAE,IAAmB;QACjD,MAAM,GAAG,GAAG,IAAI,CAAC,YAAY,EAAE,CAAC;QAChC,MAAM,QAAQ,GAAG,GAAG,CAAC,WAAW,EAAE,CAAC;QACnC,MAAM,OAAO,GAAG,GAAG,CAAC,UAAU,EAAE,CAAC;QAEjC,MAAM,MAAM,GACV,SAAS,YAAY,sBAAa;YAChC,CAAC,CAAC,SAAS,CAAC,SAAS,EAAE;YACvB,CAAC,CAAC,mBAAU,CAAC,qBAAqB,CAAC;QAEvC,MAAM,OAAO,GACX,SAAS,YAAY,sBAAa;YAChC,CAAC,CAAC,SAAS,CAAC,OAAO;YACnB,CAAC,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC;QAExB,iEAAiE;QACjE,8CAA8C;QAC9C,IAAI,CAAC;YACH,MAAM,IAAI,CAAC,QAAQ,CAAC,KAAK,CACvB,GAAG,OAAO,CAAC,MAAM,IAAI,OAAO,CAAC,GAAG,MAAM,OAAO,EAAE,EAC/C,SAAS,YAAY,KAAK,CAAC,CAAC,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC,CAAC,SAAS,EACxD,iBAAiB,CAClB,CAAC;QACJ,CAAC;QAAC,OAAO,MAAM,EAAE,CAAC;YAChB,sEAAsE;YACtE,wEAAwE;YAExE,OAAO,CAAC,KAAK,CAAC,kCAAkC,EAAE,MAAM,CAAC,CAAC;QAC5D,CAAC;QAED,wEAAwE;QACxE,IAAI,CAAC;YACH,QAAQ,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC;gBAC3B,UAAU,EAAE,MAAM;gBAClB,OAAO,EACL,SAAS,YAAY,sBAAa;oBAChC,CAAC,CAAC,SAAS,CAAC,WAAW,EAAE;oBACzB,CAAC,CAAC,uBAAuB;aAC9B,CAAC,CAAC;QACL,CAAC;QAAC,OAAO,MAAM,EAAE,CAAC;YAChB,sEAAsE;YACtE,yEAAyE;YAEzE,OAAO,CAAC,KAAK,CAAC,gCAAgC,EAAE,MAAM,CAAC,CAAC;QAC1D,CAAC;IACH,CAAC;CACF,CAAA;AAjDY,kDAAmB;8BAAnB,mBAAmB;IAD/B,IAAA,cAAK,GAAE;yDAEiC,wBAAU,oBAAV,wBAAU;GADtC,mBAAmB,CAiD/B","names":[],"sources":["/home/omar/Desktop/Protofolio_without_redis/src/log/filters/all-exceptions.filter.ts"],"sourcesContent":["import {\n  ExceptionFilter,\n  Catch,\n  ArgumentsHost,\n  HttpException,\n  HttpStatus,\n} from \"@nestjs/common\";\nimport { LogService } from \"../log.service\";\n\n@Catch()\nexport class AllExceptionsFilter implements ExceptionFilter {\n  constructor(private readonly dbLogger: LogService) {}\n\n  async catch(exception: unknown, host: ArgumentsHost) {\n    const ctx = host.switchToHttp();\n    const response = ctx.getResponse();\n    const request = ctx.getRequest();\n\n    const status =\n      exception instanceof HttpException\n        ? exception.getStatus()\n        : HttpStatus.INTERNAL_SERVER_ERROR;\n\n    const message =\n      exception instanceof HttpException\n        ? exception.message\n        : String(exception);\n\n    // Try to persist the error to DB, but don't let logging failures\n    // prevent returning a response to the client.\n    try {\n      await this.dbLogger.error(\n        `${request.method} ${request.url} | ${message}`,\n        exception instanceof Error ? exception.stack : undefined,\n        \"GlobalException\",\n      );\n    } catch (logErr) {\n      // Logging should never crash the exception flow. Fallback to console.\n      // Keep this minimal to avoid leaking sensitive info in production logs.\n\n      console.error(\"Failed to write error log to DB:\", logErr);\n    }\n\n    // Always attempt to send a response. Guard against response errors too.\n    try {\n      response.status(status).json({\n        statusCode: status,\n        message:\n          exception instanceof HttpException\n            ? exception.getResponse()\n            : \"internal server error\",\n      });\n    } catch (resErr) {\n      // If even sending response fails, log to console so the process won't\n      // silently drop the request (helps debugging \"Empty reply from server\").\n\n      console.error(\"Failed to send error response:\", resErr);\n    }\n  }\n}\n"],"version":3}